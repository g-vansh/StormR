source("~/Spring 2023/STSCI 4520/FINAL PROJECT REPOSITORY/StormR/data-raw/hurdat-creation.R", echo=TRUE)
cd ../
setwd("~/Spring 2023/STSCI 4520/FINAL PROJECT REPOSITORY/StormR")
library(usethis)
dat <- read.csv("data-raw/hurdat-raw.txt", header= FALSE)
# Convert the second column to string
dat[,2] <- as.character(dat[,2])
#We will initialize the processed data
hurdat <- data.frame(matrix(NA, 0, ncol(dat)+2))
colnames(hurdat) <- c("StormID", "StormName", "Date", "Time",
"RecordIdentifier", "SystemStatus", "Latitude",
"Longitude", "MaximumWind", "MinimumPressure", "34NE",
"34SE", "34SW", "34NW", "50NE", "50SE", "50SW",
"50NW", "64NE", "64SE", "64SW", "64NW", "RadiusMaxWind")
# counter for the row of hurdat
k <- 0
# loop over rows of raw dataset and extract the necessary data
for(i in 1:nrow(dat)){
# extract the current row of raw data
current_row <- dat[i,]
# determine if this row is a StormID
if( grepl("[a-zA-Z]", current_row[1,1])){
# if so, update the storm_id and storm_name
storm_id <- current_row[1,1]
storm_name <- gsub("\\s+", "", current_row[1,2])
} else {
# otherwise update the counter because we are adding data to
# our processed hurdat data.frame. Then, write to the next row
k <- k + 1
hurdat[k,] <- cbind(storm_id, storm_name, current_row )
}
}
#We have now formatted the dataset into a data frame. We need to finish
#cleaning up the data.
#Replace missing value codes with NAs
for(row in 1:nrow(hurdat)){
for(column in 1:ncol(hurdat)){
if (is.na(hurdat[row, column]) |
nchar(gsub("\\s", "", hurdat[row, column]))==0){
hurdat[row, column] <- NA
}
}
}
#Convert latitude and longitude columns to degrees north and
#degrees east respectively.
for(i in 1:nrow(hurdat)){
#Convert latitude to degrees north
current_latitude <- hurdat$Latitude[i]
if(grepl("S", current_latitude)){
new_latitude <- -1 * as.numeric(gsub("[A-Za-z]", "", current_latitude))
} else {
new_latitude <- as.numeric(gsub("[A-Za-z]", "", current_latitude))
}
hurdat$Latitude[i] <- new_latitude
#Convert latitude to degrees east
current_longitude <- hurdat$Longitude[i]
if(grepl("W", current_longitude)){
new_longitude <- -1 * as.numeric(gsub("[A-Za-z]", "", current_longitude))
} else {
new_longitude <- as.numeric(gsub("[A-Za-z]", "", current_longitude))
}
hurdat$Longitude[i] <- new_longitude
}
# Convert Latitude and Longitude to numeric
hurdat$Latitude <- as.numeric(hurdat$Latitude)
hurdat$Longitude <- as.numeric(hurdat$Longitude)
# Convert Date and Time to string
hurdat$Date <- as.character(hurdat$Date)
hurdat$Time <- as.character(hurdat$Time)
# Rename this file to the name of the dataset
write.csv(hurdat, "data-raw/hurdat.csv")
usethis::use_data(hurdat, overwrite = TRUE)
?geom_circle
?geom
?max
library(StormR)
#library(StormR)
load("data/hurdat.rda")
#library(StormR)
load("data/hurdat.rda")
setwd("~/Spring 2023/STSCI 4520/FINAL PROJECT REPOSITORY/StormR")
#library(StormR)
setwd("~/Spring 2023/STSCI 4520/FINAL PROJECT REPOSITORY/StormR")
load("data/hurdat.rda")
#library(StormR)
setwd("~/Spring 2023/STSCI 4520/FINAL PROJECT REPOSITORY/StormR")
load("data/hurdat.rda")
View(hurdat)
View(hurdat)
devtools::check()
install.packages("devtools")
devtools::check()
devtools::check()
knitr::opts_chunk$set(echo = TRUE)
storm_2020 <- hurdat[which(substr(hurdat$Date, start = 1, stop = 4) == "2020")]
storm_2020 <- hurdat[which(sapply(hurdat$Date, function(x) substr(x, start = 1, stop = 4)) == "2020")]
hurdat$Date
storm_2020 <- hurdat[sapply(hurdat$Date, function(x) substr(x, start = 1, stop = 4)) == "2020"]
knitr::opts_chunk$set(echo = TRUE)
# multiple-index subsetting
which( m > 4 )
knitr::opts_chunk$set(echo = TRUE)
# subsetting atomic vectors, matrices, and arrays
# subsetting lists and data frames
# atomic vectors
a <- c(1, 4, 9, 16)
a
a[3]
a[c(3,4)]
a[c(4,3)]
a[c(1,1,2,2,3)]
a[c(-1,-2)] #Returns A with the first and second indices removed
#a[c(-1, 2)] #Can't mix negative and positive indices, ERROR
a[6] #Index not in range, outputs NA
a[c(3,NA)] #Returns NA for NA index
# named atomic vectors
b <- c( e = exp(1), pi = pi, tau = 2*pi )
#left side is name and right side is the actual value
b
b[1]
b["e"] #Names can do subsetting
b[c("pi","e")]
b[c("pi",3)]
# why doesn't the last one work? Coerces 3 to the character "3" and there is no variable with this name
# logical subsetting
b
b > 4
b[ b > 4 ]
b[TRUE] #Returns entries of B for which logical vector is true.
b[c(TRUE,FALSE)] #Recycles back to True, keeps doing true false true false
which( c(TRUE,FALSE,TRUE) )
which( b > 4 ) #Only 3rd element is greater than 4
b[ which(b>4) ] #basically same as b[b>4]
# which vs logical when vector contains missing values
b <- c( e = exp(1), pi = pi, tau = 2*pi )
b <- c(b,NA)
b
b > 4
b[ b > 4 ] #Keeps the NA
which(b>4) #Drops the missing values of NA
b[ which(b>4) ]
# matrices
m <- outer( 1:4, 0.01*(1:3), "/" )
m
m[1,2]
m[1:2,2]
m[1:3,2]
m[1:3,2:3]
m[,2]
m[4,]
# be vigilant about R's automatic coercion to vectors
m[,2,drop=FALSE]
m[4,,drop=FALSE]
# treating matrix as a vector
m
m[5] #"fifth element" of the matrix
m[c(1,6,11)]
m[-2] #all elements except the 200
m > 4
m[ m > 200 ]
# multiple-index subsetting
which( m > 4 )
m[ which(m>4) ]
# subset via a matrix of row-column pairs
which( m > 4, arr.ind = TRUE )
m[ which( m > 4, arr.ind = TRUE ) ]
# see automatic coercion at work.
m[ which( m > 4, arr.ind = TRUE )[2,] ]
which( m > 4, arr.ind = TRUE )[2,]
class( which( m > 4, arr.ind = TRUE )[2,] )
which( m > 4, arr.ind = TRUE )[2,,drop=FALSE]
m[ which( m > 4, arr.ind = TRUE )[2,,drop=FALSE] ]
# arrays
arr <- array( letters[1:12], c(2,3,2) )
arr
arr[2,1,2]
arr[5]
# these look similar but do different things!
arr[2,1,2]
arr[c(2,1,2)]
# make sure it's a matrix
inds <- matrix( c(2,1,2), 1, 3, byrow = TRUE )
inds
arr[inds]
# subsetting and assignment
# vectors
a <- c(1, 4, 9, 16)
b <- c( e = exp(1), pi = pi, tau = 2*pi, NA )
a
b
b[4] <- a[1]
b
names(b)[4] <- "one"
b
b[1:3] <- a[2]
b
b[4] <- a[c(4,3)]
b
b[1:4] <- a[c(1,2)]
b
b[] <- 0
b <- 0
# matrices
m <- outer( 1:4, 0.01*(1:3), "+" )
m
m[4,3] <- 999
m
m[9] <- 888
m
m[ matrix(c(3,3),1,2) ] <- -1
m
# arrays
arr <- array( letters[1:12], c(2,3,2) )
arr
arr[1,2,1] <- "ccc"
arr
arr[5] <- "eee"
arr
arr[] <- "gone"
arr
# Lists: [ ] vs [[ ]] vs $
A <- list( 1:4, matrix(NA, 4, 3), function(x) x^2 )
A
# [ ] returns a list
A[1]
A[2]
A[3]
A[c(1,2)]
# [[ ]] returns the element of the list
A[[ 1 ]]
A[[ 2 ]]
A[[ 3 ]]
# [[ ]] and [ ] can be combined
A[[ 2 ]][4,3]
A[[ 2 ]][4,3] <- 0
A[[ 2 ]]
A[[ 2 ]][4,3]
A[[ 3 ]]
A[[ 3 ]](7)
# what does this do? Why [[ 1 ]]?
A[ 2 ][[ 1 ]][4,3]
# hierarchical indexing
A[[ c(1,2) ]]  # same as A[[1]][[2]]
A[[ 1 ]][[ 2 ]]
# wait, why does the [[ 2 ]] work?
a <- (1:4)^2
a
a[[ 2 ]]
a[ 2 ]
# $elem returns list element named "elem" (if one exists)
names(A) <- c("vec","mat","fun")
A
A$vec
A$mat
A$fun
A$fun(12)
A$mat[4,3]
# named lists can also be accessed with [[ ]]
A["vec"]
A[["vec"]]
# caution: $ does partial matching, [[ ]] does not
A$ma
A[["ma"]]
# for this reason I consider [[ ]] to be safer than $
# fewer silent bugs
# assign NULL to eliminate a list element
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A$fun <- NULL
A
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A[["fun"]] <- NULL
A
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A[[ 3 ]] <- NULL
A
b <- 1:10
b[10] <- NULL
knitr::opts_chunk$set(echo = TRUE)
# subsetting atomic vectors, matrices, and arrays
# subsetting lists and data frames
# atomic vectors
a <- c(1, 4, 9, 16)
a
a[3]
a[c(3,4)]
a[c(4,3)]
a[c(1,1,2,2,3)]
a[c(-1,-2)] #Returns A with the first and second indices removed
#a[c(-1, 2)] #Can't mix negative and positive indices, ERROR
a[6] #Index not in range, outputs NA
a[c(3,NA)] #Returns NA for NA index
# named atomic vectors
b <- c( e = exp(1), pi = pi, tau = 2*pi )
#left side is name and right side is the actual value
b
b[1]
b["e"] #Names can do subsetting
b[c("pi","e")]
b[c("pi",3)]
# why doesn't the last one work? Coerces 3 to the character "3" and there is no variable with this name
# logical subsetting
b
b > 4
b[ b > 4 ]
b[TRUE] #Returns entries of B for which logical vector is true.
b[c(TRUE,FALSE)] #Recycles back to True, keeps doing true false true false
which( c(TRUE,FALSE,TRUE) )
which( b > 4 ) #Only 3rd element is greater than 4
b[ which(b>4) ] #basically same as b[b>4]
# which vs logical when vector contains missing values
b <- c( e = exp(1), pi = pi, tau = 2*pi )
b <- c(b,NA)
b
b > 4
b[ b > 4 ] #Keeps the NA
which(b>4) #Drops the missing values of NA
b[ which(b>4) ]
# matrices
m <- outer( 1:4, 0.01*(1:3), "/" )
m
m[1,2]
m[1:2,2]
m[1:3,2]
m[1:3,2:3]
m[,2]
m[4,]
# be vigilant about R's automatic coercion to vectors
m[,2,drop=FALSE]
m[4,,drop=FALSE]
# treating matrix as a vector
m
m[5] #"fifth element" of the matrix
m[c(1,6,11)]
m[-2] #all elements except the 200
m > 4
m[ m > 200 ]
# multiple-index subsetting
which( m > 4 )
m[ which(m>4) ]
# subset via a matrix of row-column pairs
which( m > 4, arr.ind = TRUE )
m[ which( m > 4, arr.ind = TRUE ) ]
# see automatic coercion at work.
m[ which( m > 4, arr.ind = TRUE )[2,] ]
which( m > 4, arr.ind = TRUE )[2,]
class( which( m > 4, arr.ind = TRUE )[2,] )
which( m > 4, arr.ind = TRUE )[2,,drop=FALSE]
m[ which( m > 4, arr.ind = TRUE )[2,,drop=FALSE] ]
# arrays
arr <- array( letters[1:12], c(2,3,2) )
arr
arr[2,1,2]
arr[5]
# these look similar but do different things!
arr[2,1,2]
arr[c(2,1,2)]
# make sure it's a matrix
inds <- matrix( c(2,1,2), 1, 3, byrow = TRUE )
inds
arr[inds]
# subsetting and assignment
# vectors
a <- c(1, 4, 9, 16)
b <- c( e = exp(1), pi = pi, tau = 2*pi, NA )
a
b
b[4] <- a[1]
b
names(b)[4] <- "one"
b
b[1:3] <- a[2]
b
b[4] <- a[c(4,3)]
b
b[1:4] <- a[c(1,2)]
b
b[] <- 0
b <- 0
# matrices
m <- outer( 1:4, 0.01*(1:3), "+" )
m
m[4,3] <- 999
m
m[9] <- 888
m
m[ matrix(c(3,3),1,2) ] <- -1
m
# arrays
arr <- array( letters[1:12], c(2,3,2) )
arr
arr[1,2,1] <- "ccc"
arr
arr[5] <- "eee"
arr
arr[] <- "gone"
arr
# Lists: [ ] vs [[ ]] vs $
A <- list( 1:4, matrix(NA, 4, 3), function(x) x^2 )
A
# [ ] returns a list
A[1]
A[2]
A[3]
A[c(1,2)]
# [[ ]] returns the element of the list
A[[ 1 ]]
A[[ 2 ]]
A[[ 3 ]]
# [[ ]] and [ ] can be combined
A[[ 2 ]][4,3]
A[[ 2 ]][4,3] <- 0
A[[ 2 ]]
A[[ 2 ]][4,3]
A[[ 3 ]]
A[[ 3 ]](7)
# what does this do? Why [[ 1 ]]?
A[ 2 ][[ 1 ]][4,3]
# hierarchical indexing
A[[ c(1,2) ]]  # same as A[[1]][[2]]
A[[ 1 ]][[ 2 ]]
# wait, why does the [[ 2 ]] work?
a <- (1:4)^2
a
a[[ 2 ]]
a[ 2 ]
# $elem returns list element named "elem" (if one exists)
names(A) <- c("vec","mat","fun")
A
A$vec
A$mat
A$fun
A$fun(12)
A$mat[4,3]
# named lists can also be accessed with [[ ]]
A["vec"]
A[["vec"]]
# caution: $ does partial matching, [[ ]] does not
A$ma
A[["ma"]]
# for this reason I consider [[ ]] to be safer than $
# fewer silent bugs
# assign NULL to eliminate a list element
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A$fun <- NULL
A
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A[["fun"]] <- NULL
A
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A[[ 3 ]] <- NULL
A
b <- 1:10
#b[10] <- NULL
# data.frames share behavior of matrices and lists
dat <- data.frame( lets = letters[1:10], nums = 1:10 )
dat
# pull a single element
dat[5,1]
# pulling out a column coerces to atomic vector
dat[,1]
dat[,2]
# pulling out a row does not
dat[5,]
class(dat[5,])
# multiple columns
dat[,c(2,1)]
dat[,c(2,1,2)]
# single-index subsetting treats the data.frame as a list
# and does not coerce to an atomic vector
dat[ 1 ]
class( dat[ 1 ] )
dat[ 2 ]
class( dat[ 2 ] )
dat[ c(2,1) ]
# multiple indices treats it as a matrix
dat[5,1]
dat[5,2]
# can combine [ ] with names
# these behave like matrices
dat[,"lets"]
dat[,c("nums","lets")]
dat[,c("nums","nums","lets")]
# these behave like lists
dat["lets"]
dat[c("nums","lets")]
dat[c("nums","nums","lets")]
# $ works, but beware of partial matching
dat$lets
dat$lets[1:4]
# [[ ]] works
dat[[ 1 ]]
dat[[ 1 ]][3]
dat[[ c(1,3) ]] # not recommended, confusing
dat[["nums"]]
dat[["nums"]][ 6 ]
# subset function
# ?subset
subset(dat, subset = nums > 6)
subset(dat, subset = nums > 6, select = "lets")
# same as this
dat[ dat$nums > 6, ]
dat[ dat$nums > 6, "lets", drop = FALSE ]
storm_2020 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2020"]
storm_2020 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2020",]
View(storm_2020)
install.packages("C:/Users/terre/Downloads/StormR_0.0.0.9000.tar.gz", repos = NULL, type = "source")
