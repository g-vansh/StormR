which( c(TRUE,FALSE,TRUE) )
which( b > 4 ) #Only 3rd element is greater than 4
b[ which(b>4) ] #basically same as b[b>4]
# which vs logical when vector contains missing values
b <- c( e = exp(1), pi = pi, tau = 2*pi )
b <- c(b,NA)
b
b > 4
b[ b > 4 ] #Keeps the NA
which(b>4) #Drops the missing values of NA
b[ which(b>4) ]
# matrices
m <- outer( 1:4, 0.01*(1:3), "/" )
m
m[1,2]
m[1:2,2]
m[1:3,2]
m[1:3,2:3]
m[,2]
m[4,]
# be vigilant about R's automatic coercion to vectors
m[,2,drop=FALSE]
m[4,,drop=FALSE]
# treating matrix as a vector
m
m[5] #"fifth element" of the matrix
m[c(1,6,11)]
m[-2] #all elements except the 200
m > 4
m[ m > 200 ]
# multiple-index subsetting
which( m > 4 )
m[ which(m>4) ]
# subset via a matrix of row-column pairs
which( m > 4, arr.ind = TRUE )
m[ which( m > 4, arr.ind = TRUE ) ]
# see automatic coercion at work.
m[ which( m > 4, arr.ind = TRUE )[2,] ]
which( m > 4, arr.ind = TRUE )[2,]
class( which( m > 4, arr.ind = TRUE )[2,] )
which( m > 4, arr.ind = TRUE )[2,,drop=FALSE]
m[ which( m > 4, arr.ind = TRUE )[2,,drop=FALSE] ]
# arrays
arr <- array( letters[1:12], c(2,3,2) )
arr
arr[2,1,2]
arr[5]
# these look similar but do different things!
arr[2,1,2]
arr[c(2,1,2)]
# make sure it's a matrix
inds <- matrix( c(2,1,2), 1, 3, byrow = TRUE )
inds
arr[inds]
# subsetting and assignment
# vectors
a <- c(1, 4, 9, 16)
b <- c( e = exp(1), pi = pi, tau = 2*pi, NA )
a
b
b[4] <- a[1]
b
names(b)[4] <- "one"
b
b[1:3] <- a[2]
b
b[4] <- a[c(4,3)]
b
b[1:4] <- a[c(1,2)]
b
b[] <- 0
b <- 0
# matrices
m <- outer( 1:4, 0.01*(1:3), "+" )
m
m[4,3] <- 999
m
m[9] <- 888
m
m[ matrix(c(3,3),1,2) ] <- -1
m
# arrays
arr <- array( letters[1:12], c(2,3,2) )
arr
arr[1,2,1] <- "ccc"
arr
arr[5] <- "eee"
arr
arr[] <- "gone"
arr
# Lists: [ ] vs [[ ]] vs $
A <- list( 1:4, matrix(NA, 4, 3), function(x) x^2 )
A
# [ ] returns a list
A[1]
A[2]
A[3]
A[c(1,2)]
# [[ ]] returns the element of the list
A[[ 1 ]]
A[[ 2 ]]
A[[ 3 ]]
# [[ ]] and [ ] can be combined
A[[ 2 ]][4,3]
A[[ 2 ]][4,3] <- 0
A[[ 2 ]]
A[[ 2 ]][4,3]
A[[ 3 ]]
A[[ 3 ]](7)
# what does this do? Why [[ 1 ]]?
A[ 2 ][[ 1 ]][4,3]
# hierarchical indexing
A[[ c(1,2) ]]  # same as A[[1]][[2]]
A[[ 1 ]][[ 2 ]]
# wait, why does the [[ 2 ]] work?
a <- (1:4)^2
a
a[[ 2 ]]
a[ 2 ]
# $elem returns list element named "elem" (if one exists)
names(A) <- c("vec","mat","fun")
A
A$vec
A$mat
A$fun
A$fun(12)
A$mat[4,3]
# named lists can also be accessed with [[ ]]
A["vec"]
A[["vec"]]
# caution: $ does partial matching, [[ ]] does not
A$ma
A[["ma"]]
# for this reason I consider [[ ]] to be safer than $
# fewer silent bugs
# assign NULL to eliminate a list element
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A$fun <- NULL
A
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A[["fun"]] <- NULL
A
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A[[ 3 ]] <- NULL
A
b <- 1:10
b[10] <- NULL
knitr::opts_chunk$set(echo = TRUE)
# subsetting atomic vectors, matrices, and arrays
# subsetting lists and data frames
# atomic vectors
a <- c(1, 4, 9, 16)
a
a[3]
a[c(3,4)]
a[c(4,3)]
a[c(1,1,2,2,3)]
a[c(-1,-2)] #Returns A with the first and second indices removed
#a[c(-1, 2)] #Can't mix negative and positive indices, ERROR
a[6] #Index not in range, outputs NA
a[c(3,NA)] #Returns NA for NA index
# named atomic vectors
b <- c( e = exp(1), pi = pi, tau = 2*pi )
#left side is name and right side is the actual value
b
b[1]
b["e"] #Names can do subsetting
b[c("pi","e")]
b[c("pi",3)]
# why doesn't the last one work? Coerces 3 to the character "3" and there is no variable with this name
# logical subsetting
b
b > 4
b[ b > 4 ]
b[TRUE] #Returns entries of B for which logical vector is true.
b[c(TRUE,FALSE)] #Recycles back to True, keeps doing true false true false
which( c(TRUE,FALSE,TRUE) )
which( b > 4 ) #Only 3rd element is greater than 4
b[ which(b>4) ] #basically same as b[b>4]
# which vs logical when vector contains missing values
b <- c( e = exp(1), pi = pi, tau = 2*pi )
b <- c(b,NA)
b
b > 4
b[ b > 4 ] #Keeps the NA
which(b>4) #Drops the missing values of NA
b[ which(b>4) ]
# matrices
m <- outer( 1:4, 0.01*(1:3), "/" )
m
m[1,2]
m[1:2,2]
m[1:3,2]
m[1:3,2:3]
m[,2]
m[4,]
# be vigilant about R's automatic coercion to vectors
m[,2,drop=FALSE]
m[4,,drop=FALSE]
# treating matrix as a vector
m
m[5] #"fifth element" of the matrix
m[c(1,6,11)]
m[-2] #all elements except the 200
m > 4
m[ m > 200 ]
# multiple-index subsetting
which( m > 4 )
m[ which(m>4) ]
# subset via a matrix of row-column pairs
which( m > 4, arr.ind = TRUE )
m[ which( m > 4, arr.ind = TRUE ) ]
# see automatic coercion at work.
m[ which( m > 4, arr.ind = TRUE )[2,] ]
which( m > 4, arr.ind = TRUE )[2,]
class( which( m > 4, arr.ind = TRUE )[2,] )
which( m > 4, arr.ind = TRUE )[2,,drop=FALSE]
m[ which( m > 4, arr.ind = TRUE )[2,,drop=FALSE] ]
# arrays
arr <- array( letters[1:12], c(2,3,2) )
arr
arr[2,1,2]
arr[5]
# these look similar but do different things!
arr[2,1,2]
arr[c(2,1,2)]
# make sure it's a matrix
inds <- matrix( c(2,1,2), 1, 3, byrow = TRUE )
inds
arr[inds]
# subsetting and assignment
# vectors
a <- c(1, 4, 9, 16)
b <- c( e = exp(1), pi = pi, tau = 2*pi, NA )
a
b
b[4] <- a[1]
b
names(b)[4] <- "one"
b
b[1:3] <- a[2]
b
b[4] <- a[c(4,3)]
b
b[1:4] <- a[c(1,2)]
b
b[] <- 0
b <- 0
# matrices
m <- outer( 1:4, 0.01*(1:3), "+" )
m
m[4,3] <- 999
m
m[9] <- 888
m
m[ matrix(c(3,3),1,2) ] <- -1
m
# arrays
arr <- array( letters[1:12], c(2,3,2) )
arr
arr[1,2,1] <- "ccc"
arr
arr[5] <- "eee"
arr
arr[] <- "gone"
arr
# Lists: [ ] vs [[ ]] vs $
A <- list( 1:4, matrix(NA, 4, 3), function(x) x^2 )
A
# [ ] returns a list
A[1]
A[2]
A[3]
A[c(1,2)]
# [[ ]] returns the element of the list
A[[ 1 ]]
A[[ 2 ]]
A[[ 3 ]]
# [[ ]] and [ ] can be combined
A[[ 2 ]][4,3]
A[[ 2 ]][4,3] <- 0
A[[ 2 ]]
A[[ 2 ]][4,3]
A[[ 3 ]]
A[[ 3 ]](7)
# what does this do? Why [[ 1 ]]?
A[ 2 ][[ 1 ]][4,3]
# hierarchical indexing
A[[ c(1,2) ]]  # same as A[[1]][[2]]
A[[ 1 ]][[ 2 ]]
# wait, why does the [[ 2 ]] work?
a <- (1:4)^2
a
a[[ 2 ]]
a[ 2 ]
# $elem returns list element named "elem" (if one exists)
names(A) <- c("vec","mat","fun")
A
A$vec
A$mat
A$fun
A$fun(12)
A$mat[4,3]
# named lists can also be accessed with [[ ]]
A["vec"]
A[["vec"]]
# caution: $ does partial matching, [[ ]] does not
A$ma
A[["ma"]]
# for this reason I consider [[ ]] to be safer than $
# fewer silent bugs
# assign NULL to eliminate a list element
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A$fun <- NULL
A
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A[["fun"]] <- NULL
A
A <- list( vec = 1:4, mat = matrix(NA, 4, 3), fun = function(x) x^2 )
A[[ 3 ]] <- NULL
A
b <- 1:10
#b[10] <- NULL
# data.frames share behavior of matrices and lists
dat <- data.frame( lets = letters[1:10], nums = 1:10 )
dat
# pull a single element
dat[5,1]
# pulling out a column coerces to atomic vector
dat[,1]
dat[,2]
# pulling out a row does not
dat[5,]
class(dat[5,])
# multiple columns
dat[,c(2,1)]
dat[,c(2,1,2)]
# single-index subsetting treats the data.frame as a list
# and does not coerce to an atomic vector
dat[ 1 ]
class( dat[ 1 ] )
dat[ 2 ]
class( dat[ 2 ] )
dat[ c(2,1) ]
# multiple indices treats it as a matrix
dat[5,1]
dat[5,2]
# can combine [ ] with names
# these behave like matrices
dat[,"lets"]
dat[,c("nums","lets")]
dat[,c("nums","nums","lets")]
# these behave like lists
dat["lets"]
dat[c("nums","lets")]
dat[c("nums","nums","lets")]
# $ works, but beware of partial matching
dat$lets
dat$lets[1:4]
# [[ ]] works
dat[[ 1 ]]
dat[[ 1 ]][3]
dat[[ c(1,3) ]] # not recommended, confusing
dat[["nums"]]
dat[["nums"]][ 6 ]
# subset function
# ?subset
subset(dat, subset = nums > 6)
subset(dat, subset = nums > 6, select = "lets")
# same as this
dat[ dat$nums > 6, ]
dat[ dat$nums > 6, "lets", drop = FALSE ]
storm_2020 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2020"]
storm_2020 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2020",]
View(storm_2020)
install.packages("C:/Users/terre/Downloads/StormR_0.0.0.9000.tar.gz", repos = NULL, type = "source")
library(StormR)
library(StormR)
data("hurdat")
force(hurdat)
View(hurdat)
library(StormR)
View(hurdat)
library(StormR)
View(hurdat)
hurdat[1,]
library(StormR)
#Cut dataframe to only storms for that year
storm_data_2020 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2020",]
storm_data_2021 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2021",]
storm_data_2022 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2022",]
#Function to get a list of individual storms for that year
get_separated_storms <- function(df){
list_of_storms <- list()
new_storm_dataframe <- df[1,]
current_storm_id <- df$StormID[1]
for(i in 2:nrow(df)){
if (df$StormID[i] != current_storm_id){
#update current storm ID
current_storm_id <- df$StormID[i]
#append old data frame to list_of_storms
list_of_storms <- append(list_of_storms, new_storm_dataframe)
#update new data frame
new_storm_dataframe <- df[i,]
} else{
new_storm_dataframe <- rbind(new_storm_dataframe, df[i,])
}
}
return(list_of_storms)
}
#List of individual storms for each year
individual_storms_2020 <- get_separated_storms(storm_data_2020)
individual_storms_2021 <- get_separated_storms(storm_data_2021)
individual_storms_2022 <- get_separated_storms(storm_data_2022)
#Cut dataframe to only storms for that year
storm_data_2020 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2020",]
storm_data_2021 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2021",]
storm_data_2022 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2022",]
#Function to get a list of individual storms for that year
get_separated_storms <- function(df){
list_of_storms <- list()
new_storm_dataframe <- df[1,]
current_storm_id <- df$StormID[1]
for(i in 2:nrow(df)){
if (df$StormID[i] != current_storm_id){
#update current storm ID
current_storm_id <- df$StormID[i]
#append old data frame to list_of_storms
list_of_storms <- append(list_of_storms, new_storm_dataframe)
#update new data frame
new_storm_dataframe <- df[i,]
} else{
new_storm_dataframe <- rbind(new_storm_dataframe, df[i,])
}
}
return(list_of_storms)
}
#List of individual storms for each year
individual_storms_2020 <- get_separated_storms(storm_data_2020)
individual_storms_2021 <- get_separated_storms(storm_data_2021)
#individual_storms_2022 <- get_separated_storms(storm_data_2022)
#Plot 2020 Storms
StormR::plot_storm_track(individual_storms_2020)
View(hurdat)
View(individual_storms_2020)
knitr::opts_chunk$set(echo = TRUE)
#Cut dataframe to only storms for that year
storm_data_2020 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2020",]
storm_data_2021 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2021",]
storm_data_2022 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2022",]
#Function to get a list of individual storms for that year
get_separated_storms <- function(df){
list_of_storms <- list()
new_storm_dataframe <- df[1,]
current_storm_id <- df$StormID[1]
for(i in 2:nrow(df)){
if (df$StormID[i] != current_storm_id){
#update current storm ID
current_storm_id <- df$StormID[i]
#append old data frame to list_of_storms
list_of_storms <- append(list_of_storms, list(new_storm_dataframe))
#update new data frame
new_storm_dataframe <- df[i,]
} else{
new_storm_dataframe <- rbind(new_storm_dataframe, df[i,])
}
}
return(list_of_storms)
}
#List of individual storms for each year
individual_storms_2020 <- get_separated_storms(storm_data_2020)
individual_storms_2021 <- get_separated_storms(storm_data_2021)
#individual_storms_2022 <- get_separated_storms(storm_data_2022)
#Plot 2020 Storms
StormR::plot_storm_track(individual_storms_2020)
#Plot 2021 Storms
StormR::plot_storm_track(individual_storms_2021)
#Plot 2022 Storms
#StormR::plot_storm_track(individual_storms_2022)
#Cut dataframe to only storms for that year
storm_data_2020 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2020",]
storm_data_2021 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2021",]
storm_data_2022 <- hurdat[substr(hurdat$Date, start=1, stop=4) == "2022",]
#Function to get a list of individual storms for that year
get_separated_storms <- function(df){
list_of_storms <- list()
new_storm_dataframe <- df[1,]
current_storm_id <- df$StormID[1]
for(i in 2:nrow(df)){
if (df$StormID[i] != current_storm_id){
#update current storm ID
current_storm_id <- df$StormID[i]
#append old data frame to list_of_storms
list_of_storms <- append(list_of_storms, list(new_storm_dataframe))
#update new data frame
new_storm_dataframe <- df[i,]
} else{
new_storm_dataframe <- rbind(new_storm_dataframe, df[i,])
}
}
return(list_of_storms)
}
#List of individual storms for each year
individual_storms_2020 <- get_separated_storms(storm_data_2020)
individual_storms_2021 <- get_separated_storms(storm_data_2021)
#individual_storms_2022 <- get_separated_storms(storm_data_2022)
#Plot 2020 Storms
StormR::plot_storm_track(individual_storms_2020)
#Plot 2021 Storms
StormR::plot_storm_track(individual_storms_2021)
#Plot 2022 Storms
#StormR::plot_storm_track(individual_storms_2022)
